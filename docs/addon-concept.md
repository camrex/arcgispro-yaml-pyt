# ArcGIS Pro Add-in Concept

**Status:** Conceptual sketch (not yet implemented)  
**Date:** January 15, 2026

## Vision

An ArcGIS Pro Add-in that makes building and managing GIS tools as easy as saving documents. The Add-in provides the framework engine while users maintain simple Git repositories containing only YAML configs and Python business logic.

### Core Value Proposition

**"Your portable, version-controlled, multi-machine GIS toolbox"**

- Build tools in YAML (no boilerplate)
- Store in Git (automatic backup, version control)
- Sync across machines (work → home → field laptop)
- Share with colleagues (just share repo URL)

**Not trying to build an ecosystem** - just make personal tool management frictionless. If sharing emerges organically, great. If not, still solves the core problem.

## Architecture

### Framework in Add-in, Tools in Repository

**Core principle:** Add-in provides framework. Repositories contain only tool definitions (YAML + Python logic).

#### Add-in Package (Required)

```
ArcGIS Pro Add-in:
  arcgis_yaml_toolbox/
    ├─ framework/                    # Framework engine
    │   ├─ factory.py                # Dynamic tool generation
    │   ├─ loader.py                 # Tool loading
    │   ├─ base/
    │   │   └─ yaml_tool.py          # Base tool class
    │   ├─ config/
    │   │   └─ schema.py             # Pydantic validation
    │   └─ metadata/
    │       └─ generator.py          # XML metadata generation
    │
    ├─ ui/                           # ArcGIS Pro UI integration
    │   ├─ catalog.py                # Tool browser panel
    │   ├─ repository.py             # Repository management
    │   └─ sync.py                   # Optional Git integration
    │
    └─ templates/
        ├─ toolbox_template/         # New toolbox template
        ├─ tool.yml.template         # New tool template
        └─ execute.py.template       # Execute function template

**Installed once, provides framework for all toolboxes.**
```

#### User's Toolbox Repository (Clean, No Framework Code)

```
# Can be local folder, Git repo, or any VCS
my-gis-toolbox/
  ├─ tools/                          # Tool YAML configs
  │   ├─ buffer_analysis.yml
  │   ├─ clip_features.yml
  │   └─ watershed_delineation.yml
  │
  ├─ utils/                          # Python business logic
  │   ├─ buffer.py
  │   ├─ clip.py
  │   └─ watershed.py
  │
  ├─ yaml_toolbox.pyt               # Generated by Add-in
  ├─ .toolbox_manifest.yml          # Generated by Add-in
  └─ README.md

**No framework code.** Just YAML configs + Python logic.
Git is optional - can be local folder, network drive, SharePoint, etc.
```

#### Generated .pyt File (Links to Add-in Framework)

```python
# yaml_toolbox.pyt (auto-generated by Add-in)
"""
YAML-based Python Toolbox
Managed by ArcGIS YAML Toolbox Add-in

DO NOT EDIT - Regenerate via Add-in
"""

try:
    from arcgis_yaml_toolbox.framework import ToolboxLoader
except ImportError:
    raise ImportError(
        "ArcGIS YAML Toolbox Add-in required. "
        "Install from ArcGIS Pro Add-in Manager."
    )

# Load tools from this directory
_loader = ToolboxLoader(Path(__file__).parent)
_toolbox_config, _tool_classes = _loader.load_tools()

# Export for ArcGIS Pro
for tool_class in _tool_classes:
    globals()[tool_class.__name__] = tool_class

class Toolbox:
    def __init__(self):
        self.label = _toolbox_config.label
        self.tools = _tool_classes
```

**Key benefits:**
- All toolboxes use same framework version (no fragmentation)
- Framework updates via Add-in updates (tested, controlled)
- Repositories stay clean (only user code)
- Consistent behavior across all tools

## User Workflows

### First Time Setup

**Step 1: Install Add-in (Required)**
1. Open ArcGIS Pro
2. Add-in Manager → Install "YAML Toolbox Framework"
3. Framework now available for all toolboxes

**Step 2: Create Toolbox (Via Add-in UI)**
1. Open "YAML Toolbox Manager" panel
2. Click "Create New Toolbox"
3. Choose location:
   - Local folder: `e:/my-tools/`
   - Git repository: `github.com/me/gis-tools` (optional)
   - Network drive: `\\server\shared\tools\` (optional)
4. Add-in generates structure and .pyt file
5. Toolbox automatically added to Pro

**No Git required.** Can be purely local folder.

### Adding a New Tool

**Option A: Manual (advanced users)**
```bash
# Create files
tools/my_tool.yml          # Config
utils/my_tool.py           # Logic

# Add-in detects new files
"New tool detected. Enable?" → Yes
Refresh toolbox → tool available
``Via Add-in UI:**
1. Open "YAML Toolbox Manager"
2. Click "New Tool"
3. Fill form (name, label, category, parameters)
4. Click "Create"
5. Add-in generates:
   - `tools/my_tool.yml` (config)
   - `utils/my_tool.py` (template with execute function)
6. Edit `utils/my_tool.py` (add business logic)
7. Refresh toolbox → tool available

**Manual (advanced users):**
1. Create `tools/my_tool.yml` manually
2. Create `utils/my_tool.py` manually
3. Add-in detects new files via file watcher
4. Prompts: "New tool detected. Enable?"
5. User clicks "Yes" → manifest updated
6. ✅ Works standalone - no Add-in required
- ✅ Clone repo → Add to Pro → Works immediately
- ✅ Framework updates via Git pull (user controlled)
- ✅ Maximum portability and adoption
- ⚠️ Users have framework code in repo (but rarely need to touch it)

### 2. .pyt File Uses Local Framework
```python
# yaml_toolbox.pyt (in repository)
import sys
from pathlib import Path

# Add toolbox to path
toolbox_path = Path(__file__).parent
sys.path.insert(0, str(toolbox_path.parent))

# Import framework from local bundle
from toolbox.framework.factory import load_and_register_tools

# Load tools from this repository
_toolbox_config, _tool_classes = load_and_register_tools(
    toolbox_path / "tools" / "config"
)

# Export tools for Pro discovery
for tool_class in _tool_classes:
    globals()[tool_class.__name__] = tool_class

class Toolbox:
    def __init__(self):
        self.label = _toolbox_config.toolbox.label
        self.alias = _toolbox_config.toolbox.alias
        self.tools = _tool_classes
```

**This is the current implementation.** Already works standalone
_loader = ToolboxLoader(Path(__file__).parent)
_toolbox_config, _tool_classes = _loader.load_tools()

# Export tools for Pro discovery
for tool_class in _tool_classes:
    globals()[tool_class.__name__] = tool_class

class Toolbox:
    def __init__(self):
        self.label = _toolbox_config.toolbox.label
        self.tools = [tool_class for tool_class in _tool_classes]
```

**Never manually edited.** Add-in regenerates as needed.

### 3. Dependency Management

**Check, don't install (v1.0):**

```yaml
# In tool YAML
dependencies:
  python_packages:
    - scipy>=1.10
    - pandas>=2.0
  arcgis_extensions:
    - Spatial Analyst
```

**Add-in behavior:**
- Scans AGP conda environment
- Shows clear warnings if missing
- Provides install commands
- User installs manually
- No auto-install (keeps it simple, avoids breaking environments)

**Future (v2.0+):** Could add "Install for me" button if there's demand.

### 4. Repository Discovery

**Auto-discover tools in repo:**
```python
# Scan for all .yml files in tools/ directory
for yml_file in Path("tools").glob("**/*.yml"):
    # Load and validate tool config
    # Add to available tools list
```

**Manifest controls what's enabled:**
```yaml
# .toolbox_manifest.yml (auto-generated by Add-in)
enabled_tools:
  - tools/buffer_analysis.yml
  - tools/clip_features.yml
  # watershed_delineation.yml exists but disabled
```

## Open Questions

### Q1: Add-in Required vs Optional?
**Should the Add-in be required to use the framework?**

Options:
- A: Add-in required (framework lives in Add-in)
- B: Framework bundled in each repo (standalone)
- C: Hybrid approach

**✅ DECISION: Add-in REQUIRED (Option A)**

**Rationale:**
- **Prevents framework fragmentation** - Everyone on same framework version
- Avoids "this tool needs framework v1.5, that one needs v2.0" hell
- Framework updates via Add-in updates (controlled, tested)
- Consistent behavior across all toolboxes
- Simpler mental model: "Install Add-in once, create many toolboxes"

**Git is OPTIONAL:**
- Can use local folders without Git
- Can use any version control (Git, SVN, etc.)
- Git sync is just a convenience feature in Add-in
- Core functionality doesn't depend on Git

### Q2: Toolbox Refresh Mechanism?
**How does Pro detect tool changes?**

Options:
- A: Manual refresh (Ctrl+R in Catalog) - user controlled
- B: Add-in triggers refresh via API - automatic
### Phase 1: Package Framework for Add-in (3-6 months)
- Extract framework as Python package
- Create Add-in skeleton (basic UI)
- Implement toolbox creation wizard
- Generate .pyt files that import from Add-in
- No Git features yet (local folders only)
- **Goal:** Prove Add-in architecture prevents fragmentation
- **Goal:** Prove framework works great without Add-in
Options:
- A: One repo per Pro project
- B: Multiple repos, switch in Add-in
- C: Multiple repos, all loaded simultaneously

**Decision needed:** Common use case vs. complexity

### Q4: Tool Creation UI?
**How much UI for tool creation?**

Options:
- A: Full form-based tool builder (easy but complex to build)
- B: Templates only (manual YAML editing)
- C: Hybrid (wizard for simple tools, manual for complex)

**Decision needed:** MVP vs. polish

## Development Phases

### Phase 0: Current State ✅
- Framework works as standalone Python toolbox
- Requires manual .pyt class wrappers
- Tools defined in YAML
- Proven concept, documented

### Phase 1: Framework as Package (3-6 months)
- Extract framework to installable package
- Generated .pyt imports from package
- Users maintain only YAML + Python logic
- Manual Git workflow (no Add-in yet)
- **Goal:** Prove framework portability

### Phase 2: Basic Add-in (6-12 months)
- ArcGIS Pro Add-in UI
- Repository connection (local/GitHub)
- Tool discovery and enable/disable
- Git sync (commit/push/pull)
- Dependency checking with warnings
- **Goal:** Eliminate manual workflow friction

### Phase 3: Polish & Features (12-18 months)
- Tool creation wizard (optional UI)
- Multi-repo support
- Better dependency management
- Usage analytics (which tools used when)
- Tool search/filtering
- **Goal:** Production-ready for daily use

### Phase 4: Community (if adoption warrants)
- Sharing mechanisms
- Tool discovery across repos
- Ratings/reviews
- Trust indicators
- **Goal:** Enable organic ecosystem

## Success Metrics

**Personal success (Phase 1-2):**
- "I use this daily for my own tools"
- "It's easier than traditional .pyt files"
- "I haven't lost a tool in 6 months"

**Team success (Phase 2-3):**
- "My colleagues asked for access"
- "We share tools naturally now"
- "Onboarding new team members is easier"

**Community success (Phase 4):**
- "People I don't know are using it"
- "Getting unsolicited feature requests"
- "Esri people are aware of it"

## What If Esri Adopts It?

**Best outcome:** Esri adds native YAML toolbox support to ArcGIS Pro

**Response:** Celebrate! Problem solved at scale, everyone benefits.

**Philosophy:** Build something useful, share it freely, let adoption happen organically. Credit doesn't matter if the problem gets solved.

## Next Steps

1. **Use current framework** - Build real tools, find rough edges
2. **Document workflows** - Write guide for manual Git + framework usage
3. **Test portability** - Clone repo to different machine, verify it works
4. **Identify pain points** - What's annoying? That's the Add-in feature list
5. **Build incrementally** - Don't build Add-in until framework is proven daily

**Remember:** Solve your own problem first. Everything else is future speculation until you've proven the core workflow works for real daily use.

---

## References

- [Configuration Guide](configuration-guide.md) - Current framework documentation
- [Architecture](development/architecture.md) - Technical design details
- [Testing Guide](development/testing.md) - How to test tools

## Notes

This is a living document capturing conceptual thinking. As implementation progresses, migrate concrete decisions to proper documentation and archive speculative sections.
